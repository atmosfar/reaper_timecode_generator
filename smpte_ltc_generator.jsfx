desc:SMPTE LTC Timecode Generator
//tags: utility
//author: atmosfar
//version: 2.0

in_pin:none
out_pin:left output
out_pin:right output

slider1:0<0,1,1{Time-of-Day,Project Position}>Timecode Source
slider2:5<0,10,1{23.976 NDF,24,25,29.97 DF,29.97 NDF,30}>Framerate
slider3:0<0,2,1{Left,Right,Both}>Output Channel
slider4:0<0,1,1{On,Off}>Constant Output
slider5:-9<-40,0,0.1>Signal Level (dBFS)
slider6:0<-500,500,1>Sync Offset (ms)
slider7:0<-24,24,1>Timezone Offset (Hours)

@init
tod_start_time = 0;
tod_sample_counter = 0;
tod_is_initialized = 0;
last_play_state = -1;

updateFramerateConstants();

// --- Memory Allocation ---
bit_buffer = 0; // Array of 80 bits (0..79)
// Sync Word: 0011 1111 1111 1101 (Bits 64-79)
bit_buffer[64]=0; bit_buffer[65]=0; bit_buffer[66]=1; bit_buffer[67]=1;
bit_buffer[68]=1; bit_buffer[69]=1; bit_buffer[70]=1; bit_buffer[71]=1;
bit_buffer[72]=1; bit_buffer[73]=1; bit_buffer[74]=1; bit_buffer[75]=1;
bit_buffer[76]=1; bit_buffer[77]=1; bit_buffer[78]=0; bit_buffer[79]=1;

// --- State Variables ---
phase_state = -1;
bit_counter = 0;
sample_accumulator = 0;
need_frame_update = 1;
expected_next_time = -1000;
ltc_time_base = 0;
block_sample_idx = 0;

// --- Helper Functions ---

function updateFramerateConstants() (
  frame_rate = 
    slider2 == 0 ? 24000/1001 :
    slider2 == 1 ? 24 :
    slider2 == 2 ? 25 :
    slider2 == 3 ? 30000/1001 : // 29.97 DF
    slider2 == 4 ? 30000/1001 : // 29.97 NDF
    30;
    
  is_df = (slider2 == 3);
  is_25fps = (slider2 == 2);
  samples_per_bit = srate / (frame_rate * 80);
);

function updateTimecodeDisplay(hh, mm, ss, ff) (
  frame_separator = is_df ? ";" : ":";
  sprintf(#dbg_desc, "Timecode Gen: \t%02d : %02d : %02d %s %02d\t", hh, mm, ss, frame_separator, ff);
);

function timeToHmsf(total_seconds, is_df_mode) (
  nominal_fps = floor(frame_rate + 0.5);
  is_df_mode ? (
    // SMPTE 12M Drop Frame Formula using 30 fps nominal
    total_frames = floor(total_seconds * nominal_fps);
    // 2 frames are dropped per minute which isn't a multiple of 10
    // Ten minutes is 10 * 60 * 30 fps - (18*2) = 17982 frames
    drop_frames = (2 * floor((total_frames % 17982) / 1798.2)) + (18 * floor(total_frames / 17982));
    total_frames += drop_frames;
    
    ff = total_frames % 30;
    ss = floor(total_frames / 30) % 60;
    mm = floor(total_frames / 1800) % 60;
    hh = floor(total_frames / 108000) % 24;
  ) : (
    total_frames = floor(total_seconds * frame_rate + 0.0001);
    ff = total_frames % nominal_fps;
    ss = floor(total_frames / nominal_fps) % 60;
    mm = floor(total_frames / (nominal_fps * 60)) % 60;
    hh = floor(total_frames / (nominal_fps * 3600)) % 24;
  );
);

function setBit(index, val) (
  bit_buffer[index] = val ? 1 : 0;
);

function hmsfToBcd() local(u, t) (
  u = ff % 10; t = floor(ff / 10);
  setBit(0, u&1); setBit(1, u&2); setBit(2, u&4); setBit(3, u&8);
  setBit(8, t&1); setBit(9, t&2);
  
  setBit(10, is_df); 
  setBit(11, 0); 
  
  u = ss % 10; t = floor(ss / 10);
  setBit(16, u&1); setBit(17, u&2); setBit(18, u&4); setBit(19, u&8);
  setBit(24, t&1); setBit(25, t&2); setBit(26, t&4);
  
  u = mm % 10; t = floor(mm / 10);
  setBit(32, u&1); setBit(33, u&2); setBit(34, u&4); setBit(35, u&8);
  setBit(40, t&1); setBit(41, t&2); setBit(42, t&4); 
  
  u = hh % 10; t = floor(hh / 10);
  setBit(48, u&1); setBit(49, u&2); setBit(50, u&4); setBit(51, u&8);
  setBit(56, t&1); setBit(57, t&2);

  is_25fps ? (
    setBit(27, 0); setBit(43, 0); 
  ) : (
    setBit(43, 0); setBit(59, 0); 
  );
);

function calculatePolarity() local(i, count, polarity_bit_idx) (
  count = 0;
  i = 0;
  polarity_bit_idx = is_25fps ? 59 : 27;
  
  loop(64,
    i != polarity_bit_idx ? (
       bit_buffer[i] == 1 ? count += 1;
    );
    i += 1;
  );
  setBit(polarity_bit_idx, (count % 2) == 0);
);

@slider
slider1 == 0 ? slider_show(slider7, 1) : slider_show(slider7, 0);
updateFramerateConstants();

@block
// --- High-Level State & Mute Logic ---
constant_output = !slider4;
// play_state: 0=stopped, 1=playing, 2=paused, 5=recording, 6=record paused
is_stopped = (play_state == 0 || play_state == 2 || play_state == 6);
mute_signal = (is_stopped && constant_output == 0);

// Gain Calculation
gain = 10 ^ (slider5 / 20);

// --- Time Source Selection ---
!mute_signal ? (
  // slider1: 0 = TOD, 1 = Project
  slider1 == 1 ? (
    is_stopped ? (
      source_time = last_stopped_pos;
    ) : (
      source_time = play_position;
      last_stopped_pos = play_position;
    );
  ) : (
    // Time-of-Day Mode
    // Simplified: Latch once on start using dedicated flag
    tod_is_initialized == 0 ? (
       tod_start_time = time_precise();
       tod_sample_counter = 0;
       tod_is_initialized = 1;
    );
    
    source_time = tod_start_time + (tod_sample_counter / srate) + (slider7 * 3600);
    tod_sample_counter += samplesblock;
  );

  // --- Display Logic ---
  timeToHmsf(source_time, is_df);
  updateTimecodeDisplay(hh, mm, ss, ff);

  // --- Handover Preparation ---
  // Apply ms offset (slider6) to current source
  ltc_time_base = source_time + (slider6 / 1000);
  block_sample_idx = 0;

  // Safety check for samples_per_bit to prevent divide-by-zero or infinite loops
  samples_per_bit < 1.0 ? samples_per_bit = 20.0;

  // --- Jump/Seek Detection ---
  // If time shifts by more than half a frame from expected, force a resync
  threshold = 0.5 / frame_rate;
  abs(source_time - expected_next_time) > threshold ? (
    force_reload = 1;
  );

  // --- State Storage ---
  expected_next_time = source_time + (samplesblock / srate);
) : (
  // Muted output when paused
  hh = mm = ss = ff = 0;
  updateTimecodeDisplay(hh, mm, ss, ff);
  force_reload = 1; // Keep ready for when unmuted
  expected_next_time = -1000;
);

@sample
// --- High-Level Mute & Gain Check ---
!mute_signal ? (
  // --- Sample Accumulation & Timing ---
  sample_accumulator += 1;

  // Bit Boundary Check
  sample_accumulator >= samples_per_bit ? (
    // Fractional Reset to handle non-integer bit lengths (jitter prevention)
    sample_accumulator -= samples_per_bit;
    
    // Always flip phase at the start of every bit (clock edge)
    phase_state = -phase_state;
    mid_flip = 0;
    bit_counter += 1;

    // --- Handover & Buffer Update (Bit 80 Logic) ---
    (bit_counter >= 80 || force_reload) ? (
      bit_counter = 0;
      force_reload = 0;
      
      // Refresh BCD and Polarity data for the new frame
      current_time = ltc_time_base + (block_sample_idx / srate);
      timeToHmsf(current_time, is_df);
      hmsfToBcd();
      calculatePolarity();
    );
  );

  // --- Bi-Phase Mark (BPM) Synthesis ---
  // Zero ("0") has no mid-bit transition. 
  // One ("1") transitions exactly halfway through the bit.
  bit_buffer[bit_counter] == 1 ? (
    !mid_flip ? (
      sample_accumulator >= (samples_per_bit * 0.5) ? (
        phase_state = -phase_state;
        mid_flip = 1;
      );
    );
  );

  // --- Output Routing ---
  output_val = phase_state * gain;
  block_sample_idx += 1;
  
  // slider3: 0=Left, 1=Right, 2=Both
  slider3 == 0 ? (
    spl0 = output_val;
    spl1 = 0;
  ) : slider3 == 1 ? (
    spl0 = 0;
    spl1 = output_val;
  ) : (
    spl0 = spl1 = output_val;
  );
) : (
  // --- Muted Logic ---
  spl0 = spl1 = 0;
  sample_accumulator = 0;
  bit_counter = 80; // Ensure immediate reload when unmuted
);
